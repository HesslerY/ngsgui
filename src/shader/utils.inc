struct Mesh {
    isamplerBuffer elements;
    samplerBuffer vertices;
    int surface_curved_offset;
    int volume_elements_offset;
};

int elements2d_size = 5;
int elements2d_index_offset = 3;
int elements2d_curved_offset = 4;

int elements3d_size = 6;
int elements3d_index_offset = 4;

int elements2d_curved_size = 6;
int elements2d_curved_normals_offset = 0;
int elements2d_curved_points_offset = 3;

struct Element2d {
    int index;
    int curved_index;
    int vertices[3];
    vec3 pos[3];
    vec3 normals[3];
};

struct Element3d {
    int index;
    int vertices[4];
    vec3 pos[4];
};

vec3 interpolatePoint(Mesh mesh, Element2d el, vec2 lam) {
    float x = lam.x;
    float y = lam.y;
    if(el.curved_index<0) {
      return x*el.pos[0] + y*el.pos[1]+(1-x-y)*el.pos[2];
    }
    else {
      vec3 f[6];
      f[0] = el.pos[2]; // getSubTrigValue(0,0);
      f[2] = el.pos[0]; // getSubTrigValue(2,0);
      f[5] = el.pos[1]; // getSubTrigValue(0,2);
      int offset = mesh.surface_curved_offset+elements2d_curved_size*el.curved_index + elements2d_curved_points_offset;
      f[1] = texelFetch(mesh.vertices, offset+0).xyz; // getSubTrigValue(1,0);
      f[3] = texelFetch(mesh.vertices, offset+1).xyz; // getSubTrigValue(0,1);
      f[4] = texelFetch(mesh.vertices, offset+2).xyz; // getSubTrigValue(1,1);
      return 1.0*f[0] + x*x*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + y*y*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]);
    }
}

void calcNormals(inout Element2d el) {
  // flat element, normal is constant
  vec3 n = cross(el.pos[1]-el.pos[0], el.pos[2]-el.pos[0]);
  el.normals[0] = n;
  el.normals[1] = n;
  el.normals[2] = n;
}

Element2d getElement2d(Element3d tet, int face ) {
  Element2d trig;
  trig.index = tet.index;
  trig.curved_index = -1;
  int counter = 0;
  for (int i=0; i<4; i++) {
    if(i==face) continue;
    trig.vertices[counter] = tet.vertices[i];
    trig.pos[counter] = tet.pos[i];
    counter++;
  }
  calcNormals(trig);
  vec3 center = 0.25*(tet.pos[0]+tet.pos[1]+tet.pos[2]+tet.pos[3]);
  vec3 center_trig = 0.3333*(trig.pos[0]+trig.pos[1]+trig.pos[2]);
  if(dot(center_trig-center, trig.normals[0])<0) {
    trig.normals[0] = -trig.normals[0];
    trig.normals[1] = -trig.normals[1];
    trig.normals[2] = -trig.normals[2];
  }

  return trig;
}

Element2d getElement2d(Mesh mesh, int ei ) {
    Element2d el;
    int stride = elements2d_size;

    for (int i=0; i<3; i++) {
      el.vertices[i] = texelFetch(mesh.elements, stride*ei+i).r;
      el.pos[i] = texelFetch(mesh.vertices, el.vertices[i]).xyz;
    }
    el.index = texelFetch(mesh.elements, stride*ei+elements2d_index_offset).r;
    el.curved_index = texelFetch(mesh.elements, stride*ei+elements2d_curved_offset).r;
    if(el.curved_index>=0) {
        // have curved element
        for (int i=0; i<3; i++)
          el.normals[i] = texelFetch(mesh.vertices, mesh.surface_curved_offset+elements2d_curved_size*el.curved_index + elements2d_curved_normals_offset+i).xyz;
    }
    else {
      calcNormals(el);
    }

    return el;
}

Element3d getElement3d(Mesh mesh, int ei ) {
    Element3d el;
    int offset = mesh.volume_elements_offset + elements3d_size*ei;

    for (int i=0; i<4; i++) {
      el.vertices[i] = texelFetch(mesh.elements, offset+i).r;
      el.pos[i] = texelFetch(mesh.vertices, el.vertices[i]).xyz;
    }
    el.index = texelFetch(mesh.elements, offset+elements3d_index_offset).r;
    return el;
}

float CutEdge(vec4 plane, vec3 x, vec3 y) {
      float dx = dot(plane, vec4(x,1.0));
      float dy = dot(plane, vec4(y,1.0));
      return dx/(dx-dy);
}

// Cut tet with plane and store 0-4 points (and barycentric coords), return the number of intersection points
int CutElement3d( Element3d tet, float values[4], out vec3 pos[4], out vec3 lam[4] ) {
    int nvertices_behind = 0;
    int vertices_behind[3];
    int nvertices_front = 0;
    int vertices_front[3];
    for (int i=0; i<4; ++i) {
      // float dist = dot(plane, vec4(tet.pos[i],1.0));
      float dist = values[i];
      if(dist>0) {
          vertices_behind[nvertices_behind] = i;
          nvertices_behind++;
      }
      else {
          vertices_front[nvertices_front] = i;
          nvertices_front++;
      }
    }
    // vec3 lams[4] = vec3[4]( vec3(0,0,0), vec3(1,0,0), vec3(0,1,0), vec3(0,0,1)); // vec3(0,0,0));
    vec3 lams[4] = vec3[4]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,0,0));
    if( nvertices_behind==0 || nvertices_behind==4 ) return 0;
    if( nvertices_behind==3 ) {
        for (int i=0; i<3; ++i) {
          float vx = values[vertices_front[0]];
          float vy = values[vertices_behind[i]];
          float a = vx/(vx-vy);
          // float a = CutEdge(plane, tet.pos[vertices_front[0]] , tet.pos[vertices_behind[i]]);
          pos[i] =  mix(tet.pos[vertices_front[0]], tet.pos[vertices_behind[i]], a);
          lam[i] =  mix(lams[vertices_front[0]], lams[vertices_behind[i]], a);
        }
        return 3;
    }
    if( nvertices_behind==1 ) {
        for (int i=0; i<3; ++i) {
          float vx = values[vertices_behind[0]];
          float vy = values[vertices_front[i]];
          float a = vx/(vx-vy);
          // float a = CutEdge(plane, tet.pos[vertices_behind[0]], tet.pos[vertices_front[i]]);
          pos[i] =  mix(tet.pos[vertices_behind[0]], tet.pos[vertices_front[i]], a);
          lam[i] =  mix(lams[vertices_behind[0]], lams[vertices_front[i]], a);
        }
        return 3;
    }

    if( nvertices_behind==2 ) {
        float a, vx, vy;
        vx = values[vertices_front[0]];
        vy = values[vertices_behind[1]];
        a = vx/(vx-vy);
        // a = CutEdge(plane, tet.pos[vertices_front[0]], tet.pos[vertices_behind[1]]);
        pos[0] =  mix(tet.pos[vertices_front[0]], tet.pos[vertices_behind[1]], a);
        lam[0] =  mix(lams[vertices_front[0]], lams[vertices_behind[1]], a);

        vx = values[vertices_front[0]];
        vy = values[vertices_behind[0]];
        a = vx/(vx-vy);
        // a = CutEdge(plane, tet.pos[vertices_front[0]], tet.pos[vertices_behind[0]]);
        pos[1] =  mix(tet.pos[vertices_front[0]], tet.pos[vertices_behind[0]], a);
        lam[1] =  mix(lams[vertices_front[0]], lams[vertices_behind[0]], a);

        vx = values[vertices_front[1]];
        vy = values[vertices_behind[1]];
        a = vx/(vx-vy);
        // a = CutEdge(plane, tet.pos[vertices_front[1]], tet.pos[vertices_behind[1]]);
        pos[2] =  mix(tet.pos[vertices_front[1]], tet.pos[vertices_behind[1]], a);
        lam[2] =  mix(lams[vertices_front[1]], lams[vertices_behind[1]], a);

        vx = values[vertices_front[1]];
        vy = values[vertices_behind[0]];
        a = vx/(vx-vy);
        // a = CutEdge(plane, tet.pos[vertices_front[1]], tet.pos[vertices_behind[0]]);
        pos[3] =  mix(tet.pos[vertices_front[1]], tet.pos[vertices_behind[0]], a);
        lam[3] =  mix(lams[vertices_front[1]], lams[vertices_behind[0]], a);
        return 4;
    }           
}

vec3 TransformVec(mat4 MV, vec3 x) {
    return normalize(transpose(mat3(MV))*x);
}

vec3 light(vec3 color, mat4 MV, vec3 position, vec3 norm)
{
        mat3 mvt = transpose(inverse(mat3(MV)));
        // vec3 lightVector = TransformVec(MV, vec3(1,3,3));
        vec3 lightVector = vec3(1,3,3);
	vec3 n = normalize( mvt*norm );
	vec3 s = normalize( lightVector);
        vec4 p = MV*vec4(position,1);
	vec3 v = normalize( -p.xyz/p.w );
	vec3 r = reflect( -s, n );

	float ambient = 0.3;

	float sDotN = max( dot( s, n ), 0.0 );
	float diffuse = 0.7 * sDotN;

	// spec = Light[lightIndex].Ls * Material.Ks * pow( max( dot(r,v) , 0.0 ), Material.Shininess );
	float spec = pow( max( dot(r,v) , 0.0 ), 50 );
        return color*(ambient+diffuse) + spec*vec3(1,1,1);
}


/*
vec3 CalcLighting(mat4 MV, vec3 pos, vec3 normal) {
      // vec3 lightVector = TransformVec(vec3(1,3,3));
      // float ambient = 0.3;
      // float diffuse = 0.7;
      // FragColor.rgb *= 0.3+0.7*clamp(dot(normalize(normal), lightVector), 0, 1.0);
      return light(MV, pos, normal);
  }
*/

vec3 MapColor(float value)
{
    value = clamp(value, 0.0, 1.0);
    vec3 res;
    res.r = clamp(2.0-4.0*value, 0.0, 1.0);
    res.g = clamp(2.0-4.0*abs(0.5-value), 0.0, 1.0);
    res.b = clamp(4.0*value - 2.0, 0.0, 1.0);
    return res;
}

// find containing subtriangle
void getSubTrigStart(int order, int subdivision, inout vec3 lam, inout int x, inout int y, inout int dy)
{
    int n = subdivision+1;
    vec3 lamn = lam*(n);
    vec3 floor_lamn = floor(lamn);
    lam = lamn-floor_lamn;
    x=int(lamn.x);
    y=int(lamn.y);
    int z=int(lamn.z);
    int missing = n-x-y-z;

    if(missing==1) {
        dy=1;
    }
    if(missing==2) {
        dy=-1;
        x += 1;
        y += 1;
        lam.x = 1-lam.x;
        lam.y = 1-lam.y;
    }
}

float getSubTrigValue(int element, samplerBuffer coefficients, int order, int subdivision, int xtrig, int ytrig, int dy, int x, int y) {
    int t = (subdivision+1); // number of small edges in large edge
    int n = (order+1)*t; // points on edge of subtrigs
    int N = order*(subdivision+1)+1; // points on edge of trig
    int m = N-ytrig*order;
    int values_per_element = N*(N+1)/2;
    int offset=0;
    if(dy==1) {
        offset  = values_per_element - m*(m+1)/2 + xtrig*order;
        offset += m*(m+1)/2-(m-y)*(m-y+1)/2 + x;
    }
    else {
        offset  = values_per_element - m*(m+1)/2 + xtrig*order;
        offset -= (m+y)*(m+y+1)/2 - m*(m+1)/2 + x;
    }
    return texelFetch(coefficients, element*values_per_element+offset).r;
}

float getSubTetValue(int element, samplerBuffer coefficients, int order, int subdivision, int xtrig, int ytrig, int dy, int x, int y, int z) {
    // todo: implement subdivision
    int n = order+1;
    int values_per_element = n*(n+1)*(n+2)/6;
    int offset = x;

    offset += n*(n+1)*(n+2)/6 - (n-z)*(n-z+1)*(n-z+2)/6;
    n = n-z;
    offset += n*(n+1)/2 - (n-y)*(n-y+1)/2;

    return texelFetch(coefficients, element*values_per_element+offset).r;
}

float InterpolateTrig1(samplerBuffer coefficients, vec3 lam, int first, int dx, int dy) {
    float x = lam.x;
    float y = lam.y;
    float z = lam.z;
    float f[3];
    int ii=0;
    int offsety = 0;
    for (int i=0; i<=1; i++) {
      int offsetx = 0;
      for (int j=0; j<=1-i; j++) {
        f[ii] = texelFetch(coefficients, first+offsetx+offsety).r;
        offsetx += dx;
        ii++;
      }
      offsety += dy-i;
    }
    return 1.0*f[0] - 1.0*x*(f[0] - f[1]) - 1.0*y*(f[0] - f[2]);
}
float InterpolateTrig2(samplerBuffer coefficients, vec3 lam, int first, int dx, int dy) {
    float x = lam.x;
    float y = lam.y;
    float z = lam.z;
    float f[6];
    int ii=0;
    int offsety = 0;
    for (int i=0; i<=2; i++) {
      int offsetx = 0;
      for (int j=0; j<=2-i; j++) {
        f[ii] = texelFetch(coefficients, first+offsetx+offsety).r;
        offsetx += dx;
        ii++;
      }
      offsety += dy-i;
    }
    return 1.0*f[0] + pow(x, 2)*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + pow(y, 2)*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]);
}
float InterpolateTrig3(samplerBuffer coefficients, vec3 lam, int first, int dx, int dy) {
    float x = lam.x;
    float y = lam.y;
    float z = lam.z;
    float f[10];
    int ii=0;
    int offsety = 0;
    for (int i=0; i<=3; i++) {
      int offsetx = 0;
      for (int j=0; j<=3-i; j++) {
        f[ii] = texelFetch(coefficients, first+offsetx+offsety).r;
        offsetx += dx;
        ii++;
      }
      offsety += dy-i;
    }
    return 1.0*f[0] + pow(x, 3)*(-4.5*f[0] + 13.5*f[1] - 13.5*f[2] + 4.5*f[3]) - pow(x, 2)*y*(13.5*f[0] - 27.0*f[1] + 13.5*f[2] - 13.5*f[4] + 27.0*f[5] - 13.5*f[6]) + pow(x, 2)*(9.0*f[0] - 22.5*f[1] + 18.0*f[2] - 4.49999999999999*f[3]) - x*pow(y, 2)*(13.5*f[0] - 13.5*f[1] - 27.0*f[4] + 27.0*f[5] + 13.5*f[7] - 13.5*f[8]) + x*y*(18.0*f[0] - 22.5*f[1] + 4.5*f[2] - 22.5*f[4] + 27.0*f[5] - 4.5*f[6] + 4.5*f[7] - 4.5*f[8] + 4.9960036108132e-16*f[9]) - x*(5.5*f[0] - 9.0*f[1] + 4.5*f[2] - 0.999999999999998*f[3]) + pow(y, 3)*(-4.5*f[0] + 13.5*f[4] - 13.5*f[7] + 4.5*f[9]) + pow(y, 2)*(9.0*f[0] - 22.5*f[4] + 18.0*f[7] - 4.49999999999999*f[9]) - y*(5.5*f[0] - 9.0*f[4] + 4.5*f[7] - 0.999999999999998*f[9]);
}
float InterpolateTrig4(samplerBuffer coefficients, vec3 lam, int first, int dx, int dy) {
    float x = lam.x;
    float y = lam.y;
    float z = lam.z;
    float f[15];
    int ii=0;
    int offsety = 0;
    for (int i=0; i<=4; i++) {
      int offsetx = 0;
      for (int j=0; j<=4-i; j++) {
        f[ii] = texelFetch(coefficients, first+offsetx+offsety).r;
        offsetx += dx;
        ii++;
      }
      offsety += dy-i;
    }
    return 1.0*f[0] + pow(x, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[1] + 64.0*f[2] - 42.6666666666667*f[3] + 10.6666666666667*f[4]) - pow(x, 3)*y*(-42.6666666666667*f[0] + 3.5527136788005e-15*f[14] + 128.0*f[1] - 128.0*f[2] + 42.6666666666667*f[3] + 42.6666666666667*f[5] - 128.0*f[6] + 128.0*f[7] - 42.6666666666667*f[8]) + pow(x, 3)*(-26.6666666666667*f[0] + 96.0*f[1] - 128.0*f[2] + 74.6666666666667*f[3] - 16.0*f[4]) + pow(x, 2)*pow(y, 2)*(64.0*f[0] - 128.0*f[10] + 64.0*f[11] - 128.0*f[1] + 64.0*f[2] - 128.0*f[5] + 256.0*f[6] - 128.0*f[7] + 64.0*f[9]) + pow(x, 2)*y*(-80.0*f[0] + 32.0*f[10] - 16.0*f[11] + 9.473903143468e-15*f[12] + 4.736951571734e-15*f[13] + 3.25665420556713e-15*f[14] + 192.0*f[1] - 144.0*f[2] + 32.0*f[3] + 96.0*f[5] - 224.0*f[6] + 160.0*f[7] - 32.0*f[8] - 16.0*f[9]) + pow(x, 2)*(23.3333333333333*f[0] - 69.3333333333333*f[1] + 76.0*f[2] - 37.3333333333333*f[3] + 7.33333333333334*f[4]) + x*pow(y, 3)*(42.6666666666667*f[0] - 128.0*f[10] - 42.6666666666667*f[12] + 42.6666666666667*f[13] + 3.5527136788005e-15*f[14] - 42.6666666666667*f[1] - 128.0*f[5] + 128.0*f[6] + 128.0*f[9]) - x*pow(y, 2)*(80.0*f[0] - 160.0*f[10] + 16.0*f[11] - 32.0*f[12] + 32.0*f[13] + 3.5527136788005e-15*f[14] - 96.0*f[1] + 16.0*f[2] - 192.0*f[5] + 224.0*f[6] - 32.0*f[7] + 144.0*f[9]) + x*y*(46.6666666666667*f[0] - 32.0*f[10] + 4.0*f[11] - 5.33333333333334*f[12] + 5.33333333333333*f[13] + 1.03620815631681e-15*f[14] - 69.3333333333333*f[1] + 28.0*f[2] - 5.33333333333333*f[3] - 69.3333333333333*f[5] + 96.0*f[6] - 32.0*f[7] + 5.33333333333333*f[8] + 28.0*f[9]) - x*(8.33333333333333*f[0] - 16.0*f[1] + 12.0*f[2] - 5.33333333333334*f[3] + 1.0*f[4]) + pow(y, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[12] + 10.6666666666667*f[14] - 42.6666666666667*f[5] + 64.0*f[9]) + pow(y, 3)*(-26.6666666666667*f[0] + 74.6666666666667*f[12] - 16.0*f[14] + 96.0*f[5] - 128.0*f[9]) + pow(y, 2)*(23.3333333333333*f[0] - 37.3333333333333*f[12] + 7.33333333333334*f[14] - 69.3333333333333*f[5] + 76.0*f[9]) - y*(8.33333333333333*f[0] - 5.33333333333334*f[12] + 1.0*f[14] - 16.0*f[5] + 12.0*f[9]);
}


/*
trig_in_quad
+--+--+
|\1|\1|
|0\|0\|
+--+--+
|\1|\1|
|0\|0\|
+--+--+

*/

int getIndex(int N, int x, int y) {
  int res = N*(N+1)/2 - (N-y)*(N-y+1)/2;
  res += x;
  return res;
}

int getIndex(int N, int x, int y, int z) {
  int res = N*(N+1)*(N+2)/6 - (N-z)*(N-z+1)*(N-z+2)/6;
  res += getIndex(N-z, x, y);
  return res;
}

float getSubTrigValue(int element, samplerBuffer coefficients, int order, int subdivision, vec3 lam_) {
    int n = subdivision+1;
    int N = order*n+1;
    int values_per_element = N*(N+1)/2;
    vec3 lamn = lam_*(n);
    vec3 lam = lamn-floor(lamn);
    int x = int(lamn.x);
    int y = int(lamn.y);
    int z = int(lamn.z);

    int X = order*x;
    int Y = order*y;
    int Z = order*z;

    int first, dx, dy;
    if(lam.x+lam.y<1.0) { // lower left trig of quad
        first = element*values_per_element+getIndex(N,X,Y);
        dx = getIndex(N,X+1, Y)-getIndex(N,X,Y);
        dy = getIndex(N,X, Y+1)-getIndex(N,X,Y);
    }
    else { // upper right trig of quad
        first = element*values_per_element+getIndex(N,X+order,Y+order);
        dx = getIndex(N,X, Y)-getIndex(N,X+1,Y);
        dy = getIndex(N,X, Y+order-1)-getIndex(N,X,Y+order);
        lam.x = 1-lam.x;
        lam.y = 1-lam.y;
        lam.z = 1-lam.x-lam.y;
    }

    if(order==1) return InterpolateTrig1(coefficients, lam, first, dx, dy);
    if(order==2) return InterpolateTrig2(coefficients, lam, first, dx, dy);
    if(order==3) return InterpolateTrig3(coefficients, lam, first, dx, dy);
    if(order==4) return InterpolateTrig4(coefficients, lam, first, dx, dy);
    return 0.0;
}

float[4]  fetchTetValuesP1(int element, samplerBuffer coefficients, int N, ivec3 d, ivec3 s, int special_order=0) {
  float f[4];
  int values_per_element = N*(N+1)*(N+2)/6;
  int first = element*values_per_element;
  if(special_order==0) {
    int ii = 0;
    for (int k=0; k<=1; k++)
      for (int j=0; j<=1-k; j++)
        for (int i=0; i<=1-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==1) {
    int ii = 0;
    for (int k=0; k<=1; k++)
      for (int j=0; j<=1-k; j++)
        for (int i=0; i<=1-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+j), s.y+d.y*j, s.z+d.z*(j+k))).r;
  }
  if(special_order==2) {
    int ii = 0;
    for (int k=0; k<=1; k++)
      for (int j=0; j<=1-k; j++)
        for (int i=0; i<=1-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+k), s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==3) {
    int ii = 0;
    for (int k=0; k<=1; k++)
      for (int j=0; j<=1-k; j++)
        for (int i=0; i<=1-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*(j+k), s.z+d.z*(i+k))).r;
  }
  return f;
}

float[10]  fetchTetValuesP2(int element, samplerBuffer coefficients, int N, ivec3 d, ivec3 s, int special_order=0) {
  float f[10];
  int values_per_element = N*(N+1)*(N+2)/6;
  int first = element*values_per_element;
  if(special_order==0) {
    int ii = 0;
    for (int k=0; k<=2; k++)
      for (int j=0; j<=2-k; j++)
        for (int i=0; i<=2-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==1) {
    int ii = 0;
    for (int k=0; k<=2; k++)
      for (int j=0; j<=2-k; j++)
        for (int i=0; i<=2-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+j), s.y+d.y*j, s.z+d.z*(j+k))).r;
  }
  if(special_order==2) {
    int ii = 0;
    for (int k=0; k<=2; k++)
      for (int j=0; j<=2-k; j++)
        for (int i=0; i<=2-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+k), s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==3) {
    int ii = 0;
    for (int k=0; k<=2; k++)
      for (int j=0; j<=2-k; j++)
        for (int i=0; i<=2-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*(j+k), s.z+d.z*(i+k))).r;
  }
  return f;
}

float[20]  fetchTetValuesP3(int element, samplerBuffer coefficients, int N, ivec3 d, ivec3 s, int special_order=0) {
  float f[20];
  int values_per_element = N*(N+1)*(N+2)/6;
  int first = element*values_per_element;
  if(special_order==0) {
    int ii = 0;
    for (int k=0; k<=3; k++)
      for (int j=0; j<=3-k; j++)
        for (int i=0; i<=3-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==1) {
    int ii = 0;
    for (int k=0; k<=3; k++)
      for (int j=0; j<=3-k; j++)
        for (int i=0; i<=3-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+j), s.y+d.y*j, s.z+d.z*(j+k))).r;
  }
  if(special_order==2) {
    int ii = 0;
    for (int k=0; k<=3; k++)
      for (int j=0; j<=3-k; j++)
        for (int i=0; i<=3-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*(i+k), s.y+d.y*j, s.z+d.z*k)).r;
  }
  if(special_order==3) {
    int ii = 0;
    for (int k=0; k<=3; k++)
      for (int j=0; j<=3-k; j++)
        for (int i=0; i<=3-k-j; i++)
          f[ii++] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i, s.y+d.y*(j+k), s.z+d.z*(i+k))).r;
  }
  return f;
}

float  evalTetP1(float f[4], vec3 lam) {
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  return 1.0*f[0] - 1.0*x*(f[0] - f[1]) - 1.0*y*(f[0] - f[2]) - 1.0*z*(f[0] - f[3]);
}

float  evalTetP2(float f[10], vec3 lam) {
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  return 1.0*f[0] + pow(x, 2)*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) + 4.0*x*z*(f[0] - f[1] - f[6] + f[7]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + pow(y, 2)*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) + 4.0*y*z*(f[0] - f[3] - f[6] + f[8]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]) + pow(z, 2)*(2.0*f[0] - 4.0*f[6] + 2.0*f[9]) - z*(3.0*f[0] - 4.0*f[6] + 1.0*f[9]);
}
float  evalTetP3(float f[20], vec3 lam) {
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  return 1.0*f[0] + pow(x, 3)*(-4.5*f[0] + 13.5*f[1] - 13.5*f[2] + 4.5*f[3]) - pow(x, 2)*y*(13.5*f[0] - 27.0*f[1] + 13.5*f[2] - 13.5*f[4] + 27.0*f[5] - 13.5*f[6]) - pow(x, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[11] - 13.5*f[12] - 27.0*f[1] + 13.5*f[2]) + pow(x, 2)*(9.0*f[0] - 22.5*f[1] + 18.0*f[2] - 4.49999999999999*f[3]) - x*pow(y, 2)*(13.5*f[0] - 13.5*f[1] - 27.0*f[4] + 27.0*f[5] + 13.5*f[7] - 13.5*f[8]) - 27.0*x*y*z*(f[0] - f[10] + f[11] + f[13] - f[14] - f[1] - f[4] + f[5]) + x*y*(18.0*f[0] - 22.5*f[1] + 4.5*f[2] - 22.5*f[4] + 27.0*f[5] - 4.5*f[6] + 4.5*f[7] - 4.5*f[8] + 4.9960036108132e-16*f[9]) - x*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[11] + 13.5*f[16] - 13.5*f[17] - 13.5*f[1]) + x*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[11] - 4.5*f[12] + 4.5*f[16] - 4.5*f[17] + 4.9960036108132e-16*f[19] - 22.5*f[1] + 4.5*f[2]) - x*(5.5*f[0] - 9.0*f[1] + 4.5*f[2] - 0.999999999999998*f[3]) + pow(y, 3)*(-4.5*f[0] + 13.5*f[4] - 13.5*f[7] + 4.5*f[9]) - pow(y, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[13] - 13.5*f[15] - 27.0*f[4] + 13.5*f[7]) + pow(y, 2)*(9.0*f[0] - 22.5*f[4] + 18.0*f[7] - 4.49999999999999*f[9]) - y*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[13] + 13.5*f[16] - 13.5*f[18] - 13.5*f[4]) + y*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[13] - 4.5*f[15] + 4.5*f[16] - 4.5*f[18] + 4.9960036108132e-16*f[19] - 22.5*f[4] + 4.5*f[7]) - y*(5.5*f[0] - 9.0*f[4] + 4.5*f[7] - 0.999999999999998*f[9]) + pow(z, 3)*(-4.5*f[0] + 13.5*f[10] - 13.5*f[16] + 4.5*f[19]) + pow(z, 2)*(9.0*f[0] - 22.5*f[10] + 18.0*f[16] - 4.49999999999999*f[19]) - z*(5.5*f[0] - 9.0*f[10] + 4.5*f[16] - 0.999999999999998*f[19]);
}
  


float interpolate3d(int element, samplerBuffer coefficients, int order, int first, int N, vec3 lam, ivec3 d, ivec3 s) {
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  if(order==2) {
    float f[10];
    int ii=0;
    for (int k=0; k<=2; k++) {
      for (int j=0; j<=2-k; j++) {
        for (int i=0; i<=2-k-j; i++) {
          f[ii] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i,s.y+d.y*j,s.z+d.z*k)).r;
          ii++;
        }
      }
    }
    return 1.0*f[0] + pow(x, 2)*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) + 4.0*x*z*(f[0] - f[1] - f[6] + f[7]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + pow(y, 2)*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) + 4.0*y*z*(f[0] - f[3] - f[6] + f[8]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]) + pow(z, 2)*(2.0*f[0] - 4.0*f[6] + 2.0*f[9]) - z*(3.0*f[0] - 4.0*f[6] + 1.0*f[9]);
  }
  if(order==3) {
    float f[20];
    int ii=0;
    for (int k=0; k<=3; k++) {
      for (int j=0; j<=3-k; j++) {
        for (int i=0; i<=3-k-j; i++) {
          f[ii] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*i,s.y+d.y*j,s.z+d.z*k)).r;
          ii++;
        }
      }
    }
    return 1.0*f[0] + pow(x, 3)*(-4.5*f[0] + 13.5*f[1] - 13.5*f[2] + 4.5*f[3]) - pow(x, 2)*y*(13.5*f[0] - 27.0*f[1] + 13.5*f[2] - 13.5*f[4] + 27.0*f[5] - 13.5*f[6]) - pow(x, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[11] - 13.5*f[12] - 27.0*f[1] + 13.5*f[2]) + pow(x, 2)*(9.0*f[0] - 22.5*f[1] + 18.0*f[2] - 4.49999999999999*f[3]) - x*pow(y, 2)*(13.5*f[0] - 13.5*f[1] - 27.0*f[4] + 27.0*f[5] + 13.5*f[7] - 13.5*f[8]) - 27.0*x*y*z*(f[0] - f[10] + f[11] + f[13] - f[14] - f[1] - f[4] + f[5]) + x*y*(18.0*f[0] - 22.5*f[1] + 4.5*f[2] - 22.5*f[4] + 27.0*f[5] - 4.5*f[6] + 4.5*f[7] - 4.5*f[8] + 4.9960036108132e-16*f[9]) - x*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[11] + 13.5*f[16] - 13.5*f[17] - 13.5*f[1]) + x*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[11] - 4.5*f[12] + 4.5*f[16] - 4.5*f[17] + 4.9960036108132e-16*f[19] - 22.5*f[1] + 4.5*f[2]) - x*(5.5*f[0] - 9.0*f[1] + 4.5*f[2] - 0.999999999999998*f[3]) + pow(y, 3)*(-4.5*f[0] + 13.5*f[4] - 13.5*f[7] + 4.5*f[9]) - pow(y, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[13] - 13.5*f[15] - 27.0*f[4] + 13.5*f[7]) + pow(y, 2)*(9.0*f[0] - 22.5*f[4] + 18.0*f[7] - 4.49999999999999*f[9]) - y*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[13] + 13.5*f[16] - 13.5*f[18] - 13.5*f[4]) + y*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[13] - 4.5*f[15] + 4.5*f[16] - 4.5*f[18] + 4.9960036108132e-16*f[19] - 22.5*f[4] + 4.5*f[7]) - y*(5.5*f[0] - 9.0*f[4] + 4.5*f[7] - 0.999999999999998*f[9]) + pow(z, 3)*(-4.5*f[0] + 13.5*f[10] - 13.5*f[16] + 4.5*f[19]) + pow(z, 2)*(9.0*f[0] - 22.5*f[10] + 18.0*f[16] - 4.49999999999999*f[19]) - z*(5.5*f[0] - 9.0*f[10] + 4.5*f[16] - 0.999999999999998*f[19]);
  }
  float f[4];
  int p = order;
  f[0] = texelFetch(coefficients, first+getIndex(N,s.x,s.y,s.z)).r;
  f[1] = texelFetch(coefficients, first+getIndex(N,s.x+d.x*p,s.y,      s.z)).r;
  f[2] = texelFetch(coefficients, first+getIndex(N,s.x      ,s.y+d.y*p,s.z)).r;
  f[3] = texelFetch(coefficients, first+getIndex(N,s.x      ,s.y,      s.z+d.z*p)).r;
  return 1.0*f[0] - 1.0*x*(f[0] - f[1]) - 1.0*y*(f[0] - f[2]) - 1.0*z*(f[0] - f[3]);
}

       
float getSubTetValue(int element, samplerBuffer coefficients, int order, int subdivision, vec3 lam_) {
/*

  Coefficients are stored in a cube-like grid. Cut this cube in two prisms (1-3 and 5-7 are cutting lines) and divide the resulting prisms in 3 tets each. Each of the resulting tet has values assigned to do p-interpolation (i.e. 4 values for P1, 10 values for P2 etc.). This function determines to which subtet the point belongs and does the interpolation appropriately using the corresponding values.

          7+-----+6
          /|    /|
         / |   / |
       4+-----+5 |
        | 3+--|- +2 
        | /   | /
        |/    |/
       0+-----+1 
*/
  int n = subdivision+1;
  int N = order*n+1;
  int values_per_element = N*(N+1)*(N+2)/6;
  vec3 lamn = lam_*n;
  vec3 lam = lamn-floor(lamn);
  ivec3 s = order*ivec3(lamn);

  ivec3 d = ivec3(1,1,1);
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  int special_order = 0;
  int first = element*values_per_element;
  if(lam.x+lam.y<1.0) { // first prism: 0,1,3,4,5,7
    if(lam.x+lam.y+lam.z<1.0) { // first tet in first prism 0,1,3,4
      // default settings, nothing to do
    }
    else if(lam.x<lam.z) { // second tet in first prism 1,3,4,7
      z = 1-z;
      s.z+=order;
      d.z = -1;
    }
    else { // third tet in first prism 1,4,5,7
      x = 1-lam.x-lam.y;
      z = 1-lam.z-lam.y;
      s.z+=order;
      s.x+=order;
      d.x = -1;
      d.z = -1;
      special_order = 1;
    }
  }
  else { // second prism 1,2,3,5,6,7
    if(x+y+z>=2.0) { // first tet in second prism 2,5,6,7
      x = 1-x;
      y = 1-y;
      z = 1-z;
      d.x = -1;
      d.y = -1;
      d.z = -1;
      s.x += order;
      s.y += order;
      s.z += order;
      // return interpolate3d(element, coefficients, order, first, N, vec3(x,y,z), d, s);
    }
    else if(lam.z<lam.y) { // second tet in second prism 1,2,3,7
      x = 1-lam.x-lam.z;
      y = 1-lam.y;
      s.x+=order;
      s.y+=order;
      d.x = -1;
      d.y = -1;
      special_order = 2;
    }
    else { // third tet in second prism 1,2,5,7
      x = 1-lam.x;
      y = 2-lam.x-lam.y-lam.z;
      z = lam.z+lam.x-1;
      s.x+=order;
      s.y+=order;
      d.x = -1;
      d.y = -1;
      special_order = 3;
    }
  }
  if(order==1)
    return evalTetP1( fetchTetValuesP1(element, coefficients, N, d, s, special_order), vec3(x,y,z) );
  if(order==2)
    return evalTetP2( fetchTetValuesP2(element, coefficients, N, d, s, special_order), vec3(x,y,z) );
  if(order==3)
    return evalTetP3( fetchTetValuesP3(element, coefficients, N, d, s, special_order), vec3(x,y,z) );
}


float InterpolateTrig(int element, samplerBuffer coefficients, int order, int subdivision, vec3 lam) {
  return getSubTrigValue(element, coefficients, order, subdivision, lam);
  int trigx=0;
  int trigy=0;
  int dy=1;
  getSubTrigStart(order, subdivision, lam, trigx, trigy, dy);
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  float value = 0.0;
  if (order==1) {
    float f[3];
    f[0] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0);
    f[1] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0);
    f[2] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1);
    value = 1.0*f[0] - 1.0*x*(f[0] - f[1]) - 1.0*y*(f[0] - f[2]);
  }
  if (order==2) {
    float f[6];
    f[0] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0);
    f[1] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0);
    f[2] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0);
    f[3] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1);
    f[4] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1);
    f[5] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2);
    value = 1.0*f[0] + pow(x, 2)*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + pow(y, 2)*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]);
  }
  if (order==3) {
    float f[10];
    f[0] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0);
    f[1] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0);
    f[2] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0);
    f[3] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,0);
    f[4] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1);
    f[5] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1);
    f[6] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,1);
    f[7] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2);
    f[8] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,2);
    f[9] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,3);
    value = 1.0*f[0] + pow(x, 3)*(-4.5*f[0] + 13.5*f[1] - 13.5*f[2] + 4.5*f[3]) - pow(x, 2)*y*(13.5*f[0] - 27.0*f[1] + 13.5*f[2] - 13.5*f[4] + 27.0*f[5] - 13.5*f[6]) + pow(x, 2)*(9.0*f[0] - 22.5*f[1] + 18.0*f[2] - 4.49999999999999*f[3]) - x*pow(y, 2)*(13.5*f[0] - 13.5*f[1] - 27.0*f[4] + 27.0*f[5] + 13.5*f[7] - 13.5*f[8]) + x*y*(18.0*f[0] - 22.5*f[1] + 4.5*f[2] - 22.5*f[4] + 27.0*f[5] - 4.5*f[6] + 4.5*f[7] - 4.5*f[8] + 4.9960036108132e-16*f[9]) - x*(5.5*f[0] - 9.0*f[1] + 4.5*f[2] - 0.999999999999998*f[3]) + pow(y, 3)*(-4.5*f[0] + 13.5*f[4] - 13.5*f[7] + 4.5*f[9]) + pow(y, 2)*(9.0*f[0] - 22.5*f[4] + 18.0*f[7] - 4.49999999999999*f[9]) - y*(5.5*f[0] - 9.0*f[4] + 4.5*f[7] - 0.999999999999998*f[9]);
  }
  if (order==4) {
    float f[15];
    f[0] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0);
    f[1] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0);
    f[2] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0);
    f[3] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,0);
    f[4] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 4,0);
    f[5] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1);
    f[6] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1);
    f[7] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,1);
    f[8] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,1);
    f[9] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2);
    f[10] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,2);
    f[11] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,2);
    f[12] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,3);
    f[13] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,3);
    f[14] = getSubTrigValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,4);
    value = 1.0*f[0] + pow(x, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[1] + 64.0*f[2] - 42.6666666666667*f[3] + 10.6666666666667*f[4]) - pow(x, 3)*y*(-42.6666666666667*f[0] + 3.5527136788005e-15*f[14] + 128.0*f[1] - 128.0*f[2] + 42.6666666666667*f[3] + 42.6666666666667*f[5] - 128.0*f[6] + 128.0*f[7] - 42.6666666666667*f[8]) + pow(x, 3)*(-26.6666666666667*f[0] + 96.0*f[1] - 128.0*f[2] + 74.6666666666667*f[3] - 16.0*f[4]) + pow(x, 2)*pow(y, 2)*(64.0*f[0] - 128.0*f[10] + 64.0*f[11] - 128.0*f[1] + 64.0*f[2] - 128.0*f[5] + 256.0*f[6] - 128.0*f[7] + 64.0*f[9]) + pow(x, 2)*y*(-80.0*f[0] + 32.0*f[10] - 16.0*f[11] + 9.473903143468e-15*f[12] + 4.736951571734e-15*f[13] + 3.25665420556713e-15*f[14] + 192.0*f[1] - 144.0*f[2] + 32.0*f[3] + 96.0*f[5] - 224.0*f[6] + 160.0*f[7] - 32.0*f[8] - 16.0*f[9]) + pow(x, 2)*(23.3333333333333*f[0] - 69.3333333333333*f[1] + 76.0*f[2] - 37.3333333333333*f[3] + 7.33333333333334*f[4]) + x*pow(y, 3)*(42.6666666666667*f[0] - 128.0*f[10] - 42.6666666666667*f[12] + 42.6666666666667*f[13] + 3.5527136788005e-15*f[14] - 42.6666666666667*f[1] - 128.0*f[5] + 128.0*f[6] + 128.0*f[9]) - x*pow(y, 2)*(80.0*f[0] - 160.0*f[10] + 16.0*f[11] - 32.0*f[12] + 32.0*f[13] + 3.5527136788005e-15*f[14] - 96.0*f[1] + 16.0*f[2] - 192.0*f[5] + 224.0*f[6] - 32.0*f[7] + 144.0*f[9]) + x*y*(46.6666666666667*f[0] - 32.0*f[10] + 4.0*f[11] - 5.33333333333334*f[12] + 5.33333333333333*f[13] + 1.03620815631681e-15*f[14] - 69.3333333333333*f[1] + 28.0*f[2] - 5.33333333333333*f[3] - 69.3333333333333*f[5] + 96.0*f[6] - 32.0*f[7] + 5.33333333333333*f[8] + 28.0*f[9]) - x*(8.33333333333333*f[0] - 16.0*f[1] + 12.0*f[2] - 5.33333333333334*f[3] + 1.0*f[4]) + pow(y, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[12] + 10.6666666666667*f[14] - 42.6666666666667*f[5] + 64.0*f[9]) + pow(y, 3)*(-26.6666666666667*f[0] + 74.6666666666667*f[12] - 16.0*f[14] + 96.0*f[5] - 128.0*f[9]) + pow(y, 2)*(23.3333333333333*f[0] - 37.3333333333333*f[12] + 7.33333333333334*f[14] - 69.3333333333333*f[5] + 76.0*f[9]) - y*(8.33333333333333*f[0] - 5.33333333333334*f[12] + 1.0*f[14] - 16.0*f[5] + 12.0*f[9]);
  }
  return value;
}
float InterpolateTet(int element, samplerBuffer coefficients, int order, int subdivision, vec3 lam) {
  return getSubTetValue(element, coefficients, order, subdivision, lam);
  int trigx=0;
  int trigy=0;
  int dy=1;
  getSubTrigStart(order, subdivision, lam, trigx, trigy, dy);
  float x = lam.x;
  float y = lam.y;
  float z = lam.z;
  float value = 0.0;
  if (order==1) {
    float f[4];
    f[0] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,0);
    f[1] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,0);
    f[2] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,0);
    f[3] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,1);
    value = 1.0*f[0] - 1.0*x*(f[0] - f[1]) - 1.0*y*(f[0] - f[2]) - 1.0*z*(f[0] - f[3]);
  }
  if (order==2) {
    float f[10];
    f[0] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,0);
    f[1] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,0);
    f[2] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,0);
    f[3] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,0);
    f[4] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,0);
    f[5] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,0);
    f[6] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,1);
    f[7] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,1);
    f[8] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,1);
    f[9] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,2);
    value = 1.0*f[0] + pow(x, 2)*(2.0*f[0] - 4.0*f[1] + 2.0*f[2]) + 4.0*x*y*(f[0] - f[1] - f[3] + f[4]) + 4.0*x*z*(f[0] - f[1] - f[6] + f[7]) - x*(3.0*f[0] - 4.0*f[1] + 1.0*f[2]) + pow(y, 2)*(2.0*f[0] - 4.0*f[3] + 2.0*f[5]) + 4.0*y*z*(f[0] - f[3] - f[6] + f[8]) - y*(3.0*f[0] - 4.0*f[3] + 1.0*f[5]) + pow(z, 2)*(2.0*f[0] - 4.0*f[6] + 2.0*f[9]) - z*(3.0*f[0] - 4.0*f[6] + 1.0*f[9]);
  }
  if (order==3) {
    float f[20];
    f[0] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,0);
    f[1] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,0);
    f[2] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,0);
    f[3] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,0,0);
    f[4] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,0);
    f[5] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,0);
    f[6] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,1,0);
    f[7] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,0);
    f[8] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,2,0);
    f[9] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,3,0);
    f[10] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,1);
    f[11] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,1);
    f[12] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,1);
    f[13] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,1);
    f[14] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,1);
    f[15] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,1);
    f[16] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,2);
    f[17] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,2);
    f[18] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,2);
    f[19] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,3);
    value = 1.0*f[0] + pow(x, 3)*(-4.5*f[0] + 13.5*f[1] - 13.5*f[2] + 4.5*f[3]) - pow(x, 2)*y*(13.5*f[0] - 27.0*f[1] + 13.5*f[2] - 13.5*f[4] + 27.0*f[5] - 13.5*f[6]) - pow(x, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[11] - 13.5*f[12] - 27.0*f[1] + 13.5*f[2]) + pow(x, 2)*(9.0*f[0] - 22.5*f[1] + 18.0*f[2] - 4.49999999999999*f[3]) - x*pow(y, 2)*(13.5*f[0] - 13.5*f[1] - 27.0*f[4] + 27.0*f[5] + 13.5*f[7] - 13.5*f[8]) - 27.0*x*y*z*(f[0] - f[10] + f[11] + f[13] - f[14] - f[1] - f[4] + f[5]) + x*y*(18.0*f[0] - 22.5*f[1] + 4.5*f[2] - 22.5*f[4] + 27.0*f[5] - 4.5*f[6] + 4.5*f[7] - 4.5*f[8] + 4.9960036108132e-16*f[9]) - x*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[11] + 13.5*f[16] - 13.5*f[17] - 13.5*f[1]) + x*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[11] - 4.5*f[12] + 4.5*f[16] - 4.5*f[17] + 4.9960036108132e-16*f[19] - 22.5*f[1] + 4.5*f[2]) - x*(5.5*f[0] - 9.0*f[1] + 4.5*f[2] - 0.999999999999998*f[3]) + pow(y, 3)*(-4.5*f[0] + 13.5*f[4] - 13.5*f[7] + 4.5*f[9]) - pow(y, 2)*z*(13.5*f[0] - 13.5*f[10] + 27.0*f[13] - 13.5*f[15] - 27.0*f[4] + 13.5*f[7]) + pow(y, 2)*(9.0*f[0] - 22.5*f[4] + 18.0*f[7] - 4.49999999999999*f[9]) - y*pow(z, 2)*(13.5*f[0] - 27.0*f[10] + 27.0*f[13] + 13.5*f[16] - 13.5*f[18] - 13.5*f[4]) + y*z*(18.0*f[0] - 22.5*f[10] + 27.0*f[13] - 4.5*f[15] + 4.5*f[16] - 4.5*f[18] + 4.9960036108132e-16*f[19] - 22.5*f[4] + 4.5*f[7]) - y*(5.5*f[0] - 9.0*f[4] + 4.5*f[7] - 0.999999999999998*f[9]) + pow(z, 3)*(-4.5*f[0] + 13.5*f[10] - 13.5*f[16] + 4.5*f[19]) + pow(z, 2)*(9.0*f[0] - 22.5*f[10] + 18.0*f[16] - 4.49999999999999*f[19]) - z*(5.5*f[0] - 9.0*f[10] + 4.5*f[16] - 0.999999999999998*f[19]);
  }
  if (order==4) {
    float f[35];
    f[0] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,0);
    f[1] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,0);
    f[2] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,0);
    f[3] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,0,0);
    f[4] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 4,0,0);
    f[5] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,0);
    f[6] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,0);
    f[7] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,1,0);
    f[8] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,1,0);
    f[9] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,0);
    f[10] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,2,0);
    f[11] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,2,0);
    f[12] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,3,0);
    f[13] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,3,0);
    f[14] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,4,0);
    f[15] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,1);
    f[16] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,1);
    f[17] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,1);
    f[18] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 3,0,1);
    f[19] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,1);
    f[20] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,1);
    f[21] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,1,1);
    f[22] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,1);
    f[23] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,2,1);
    f[24] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,3,1);
    f[25] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,2);
    f[26] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,2);
    f[27] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 2,0,2);
    f[28] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,2);
    f[29] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,1,2);
    f[30] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,2,2);
    f[31] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,3);
    f[32] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 1,0,3);
    f[33] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,1,3);
    f[34] = getSubTetValue(element, coefficients, order, subdivision, trigx, trigy, dy, 0,0,4);
    value = 1.0*f[0] + pow(x, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[1] + 64.0*f[2] - 42.6666666666667*f[3] + 10.6666666666667*f[4]) - pow(x, 3)*y*(-42.6666666666667*f[0] + 3.5527136788005e-15*f[14] + 128.0*f[1] - 128.0*f[2] + 42.6666666666667*f[3] + 42.6666666666667*f[5] - 128.0*f[6] + 128.0*f[7] - 42.6666666666667*f[8]) - pow(x, 3)*z*(-42.6666666666667*f[0] + 42.6666666666667*f[15] - 128.0*f[16] + 128.0*f[17] - 42.6666666666667*f[18] + 128.0*f[1] - 128.0*f[2] + 3.5527136788005e-15*f[34] + 42.6666666666667*f[3]) + pow(x, 3)*(-26.6666666666667*f[0] + 96.0*f[1] - 128.0*f[2] + 74.6666666666667*f[3] - 16.0*f[4]) + pow(x, 2)*pow(y, 2)*(64.0*f[0] - 128.0*f[10] + 64.0*f[11] - 128.0*f[1] + 64.0*f[2] - 128.0*f[5] + 256.0*f[6] - 128.0*f[7] + 64.0*f[9]) + pow(x, 2)*y*z*(128.0*f[0] - 128.0*f[15] + 256.0*f[16] - 128.0*f[17] + 128.0*f[19] - 256.0*f[1] - 256.0*f[20] + 128.0*f[21] + 128.0*f[2] + 1.1842378929335e-14*f[31] + 2.368475785867e-15*f[33] - 9.473903143468e-15*f[34] - 128.0*f[5] + 256.0*f[6] - 128.0*f[7]) + pow(x, 2)*y*(-80.0*f[0] + 32.0*f[10] - 16.0*f[11] + 9.473903143468e-15*f[12] + 4.736951571734e-15*f[13] + 3.25665420556713e-15*f[14] + 192.0*f[1] - 144.0*f[2] + 32.0*f[3] + 96.0*f[5] - 224.0*f[6] + 160.0*f[7] - 32.0*f[8] - 16.0*f[9]) + pow(x, 2)*pow(z, 2)*(64.0*f[0] - 128.0*f[15] + 256.0*f[16] - 128.0*f[17] - 128.0*f[1] + 64.0*f[25] - 128.0*f[26] + 64.0*f[27] + 64.0*f[2]) + pow(x, 2)*z*(-80.0*f[0] + 96.0*f[15] - 224.0*f[16] + 160.0*f[17] - 32.0*f[18] + 192.0*f[1] - 16.0*f[25] + 32.0*f[26] - 16.0*f[27] - 144.0*f[2] + 9.473903143468e-15*f[31] + 4.736951571734e-15*f[32] + 3.25665420556713e-15*f[34] + 32.0*f[3]) + pow(x, 2)*(23.3333333333333*f[0] - 69.3333333333333*f[1] + 76.0*f[2] - 37.3333333333333*f[3] + 7.33333333333334*f[4]) + x*pow(y, 3)*(42.6666666666667*f[0] - 128.0*f[10] - 42.6666666666667*f[12] + 42.6666666666667*f[13] + 3.5527136788005e-15*f[14] - 42.6666666666667*f[1] - 128.0*f[5] + 128.0*f[6] + 128.0*f[9]) + x*pow(y, 2)*z*(128.0*f[0] - 128.0*f[10] - 128.0*f[15] + 128.0*f[16] + 256.0*f[19] - 128.0*f[1] - 256.0*f[20] - 128.0*f[22] + 128.0*f[23] + 7.105427357601e-15*f[31] - 7.105427357601e-15*f[34] - 256.0*f[5] + 256.0*f[6] + 128.0*f[9]) - x*pow(y, 2)*(80.0*f[0] - 160.0*f[10] + 16.0*f[11] - 32.0*f[12] + 32.0*f[13] + 3.5527136788005e-15*f[14] - 96.0*f[1] + 16.0*f[2] - 192.0*f[5] + 224.0*f[6] - 32.0*f[7] + 144.0*f[9]) + x*y*pow(z, 2)*(128.0*f[0] - 256.0*f[15] + 256.0*f[16] + 256.0*f[19] - 128.0*f[1] - 256.0*f[20] + 128.0*f[25] - 128.0*f[26] - 128.0*f[28] + 128.0*f[29] - 128.0*f[5] + 128.0*f[6]) + x*y*z*(-160.0*f[0] + 32.0*f[10] + 192.0*f[15] - 224.0*f[16] + 32.0*f[17] - 224.0*f[19] + 192.0*f[1] + 256.0*f[20] - 32.0*f[21] + 32.0*f[22] - 32.0*f[23] - 32.0*f[25] + 32.0*f[26] + 32.0*f[28] - 32.0*f[29] - 32.0*f[2] + 1.83556873404693e-14*f[31] + 3.5527136788005e-15*f[32] + 2.96059473233375e-15*f[33] + 5.03301104496738e-15*f[34] + 192.0*f[5] - 224.0*f[6] + 32.0*f[7] - 32.0*f[9]) + x*y*(46.6666666666667*f[0] - 32.0*f[10] + 4.0*f[11] - 5.33333333333334*f[12] + 5.33333333333333*f[13] + 1.03620815631681e-15*f[14] - 69.3333333333333*f[1] + 28.0*f[2] - 5.33333333333333*f[3] - 69.3333333333333*f[5] + 96.0*f[6] - 32.0*f[7] + 5.33333333333333*f[8] + 28.0*f[9]) + x*pow(z, 3)*(42.6666666666667*f[0] - 128.0*f[15] + 128.0*f[16] - 42.6666666666667*f[1] + 128.0*f[25] - 128.0*f[26] - 42.6666666666667*f[31] + 42.6666666666667*f[32] + 3.5527136788005e-15*f[34]) - x*pow(z, 2)*(80.0*f[0] - 192.0*f[15] + 224.0*f[16] - 32.0*f[17] - 96.0*f[1] + 144.0*f[25] - 160.0*f[26] + 16.0*f[27] + 16.0*f[2] - 32.0*f[31] + 32.0*f[32] + 3.5527136788005e-15*f[34]) + x*z*(46.6666666666667*f[0] - 69.3333333333333*f[15] + 96.0*f[16] - 32.0*f[17] + 5.33333333333333*f[18] - 69.3333333333333*f[1] + 28.0*f[25] - 32.0*f[26] + 4.0*f[27] + 28.0*f[2] - 5.33333333333334*f[31] + 5.33333333333333*f[32] + 1.03620815631681e-15*f[34] - 5.33333333333333*f[3]) - x*(8.33333333333333*f[0] - 16.0*f[1] + 12.0*f[2] - 5.33333333333334*f[3] + 1.0*f[4]) + pow(y, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[12] + 10.6666666666667*f[14] - 42.6666666666667*f[5] + 64.0*f[9]) - pow(y, 3)*z*(-42.6666666666667*f[0] + 42.6666666666667*f[12] + 42.6666666666667*f[15] - 128.0*f[19] + 128.0*f[22] - 42.6666666666667*f[24] + 3.5527136788005e-15*f[34] + 128.0*f[5] - 128.0*f[9]) + pow(y, 3)*(-26.6666666666667*f[0] + 74.6666666666667*f[12] - 16.0*f[14] + 96.0*f[5] - 128.0*f[9]) + pow(y, 2)*pow(z, 2)*(64.0*f[0] - 128.0*f[15] + 256.0*f[19] - 128.0*f[22] + 64.0*f[25] - 128.0*f[28] + 64.0*f[30] - 128.0*f[5] + 64.0*f[9]) + pow(y, 2)*z*(-80.0*f[0] + 32.0*f[12] + 96.0*f[15] - 224.0*f[19] + 160.0*f[22] - 32.0*f[24] - 16.0*f[25] + 32.0*f[28] - 16.0*f[30] + 9.473903143468e-15*f[31] + 4.736951571734e-15*f[33] + 3.25665420556713e-15*f[34] + 192.0*f[5] - 144.0*f[9]) + pow(y, 2)*(23.3333333333333*f[0] - 37.3333333333333*f[12] + 7.33333333333334*f[14] - 69.3333333333333*f[5] + 76.0*f[9]) + y*pow(z, 3)*(42.6666666666667*f[0] - 128.0*f[15] + 128.0*f[19] + 128.0*f[25] - 128.0*f[28] - 42.6666666666667*f[31] + 42.6666666666667*f[33] + 3.5527136788005e-15*f[34] - 42.6666666666667*f[5]) - y*pow(z, 2)*(80.0*f[0] - 192.0*f[15] + 224.0*f[19] - 32.0*f[22] + 144.0*f[25] - 160.0*f[28] + 16.0*f[30] - 32.0*f[31] + 32.0*f[33] + 3.5527136788005e-15*f[34] - 96.0*f[5] + 16.0*f[9]) + y*z*(46.6666666666667*f[0] - 5.33333333333333*f[12] - 69.3333333333333*f[15] + 96.0*f[19] - 32.0*f[22] + 5.33333333333333*f[24] + 28.0*f[25] - 32.0*f[28] + 4.0*f[30] - 5.33333333333334*f[31] + 5.33333333333333*f[33] + 1.03620815631681e-15*f[34] - 69.3333333333333*f[5] + 28.0*f[9]) - y*(8.33333333333333*f[0] - 5.33333333333334*f[12] + 1.0*f[14] - 16.0*f[5] + 12.0*f[9]) + pow(z, 4)*(10.6666666666667*f[0] - 42.6666666666667*f[15] + 64.0*f[25] - 42.6666666666667*f[31] + 10.6666666666667*f[34]) + pow(z, 3)*(-26.6666666666667*f[0] + 96.0*f[15] - 128.0*f[25] + 74.6666666666667*f[31] - 16.0*f[34]) + pow(z, 2)*(23.3333333333333*f[0] - 69.3333333333333*f[15] + 76.0*f[25] - 37.3333333333333*f[31] + 7.33333333333334*f[34]) - z*(8.33333333333333*f[0] - 16.0*f[15] + 12.0*f[25] - 5.33333333333334*f[31] + 1.0*f[34]);
  }
  return value;
}
